# 定义表示谓词

当我们使用验证工具验证一个程序时，首先需要形式化该程序中涉及的数据结构的存储方式。用于刻画数据结构存储方式的谓词称为表示谓词，表示谓词需要在Coq中定义。下面我们以“单链表”为例，展示在使用验证工具时如何在Coq中定义单链表的表示谓词。

## 以单链表为例

下面的是用C语言实现的“单链表”的定义：

```c
struct list {
 int data;
 struct list *next;
};
```

其对应的Coq中的表示谓词应当定义如下（sll是指singly-linked-list）：

```Coq
Fixpoint sll (x: addr) (l: list Z): Assertion :=
  match l with
    | nil     => [| x = NULL |] && emp
    | z :: l0 => [| x <> NULL |] &&
                 EX y: addr,
                   &(x # "list" ->ₛ "data") # Int |-> z ** 
                   &(x # "list" ->ₛ "next") # Ptr |-> y **
                   sll y l0
  end.
```

其中，`Assertion`是验证工具中定义的一个类型，表示“关于C语言内存的断言”，具体而言：

- 这些Assertion可以描述内存中存储了什么；
- 这些Assertion不会描述关于C程序局部变量地址的环境信息；
- 这些Assertion可以描述关于C程序全局变量的信息；
- C程序的struct/union/typedef相关的类型信息，可以在Assertion中涉及；
- 如果只考虑32位整数，以及32位的指针，内存可以简化地看作地址到32位值的部分映射，但是我们的验证工具实际是会处理8位、16位、64位的情形的。

这一定义中用到了如下语法：

- 如果``x``是一个Coq中``addr``类型的表达式，那么``x # "list"``表示C类型为``list``（可能是一个struct）的指针的一个右值表达式的值，其值为``x``；

- 如果``p``表示一个C语言struct类型指针的右值表达式的值，那么``p ->ₛ "data"``表示取``p``的``data``域这个左值表达式；

- 如果``p``是一个左值表达式，那么``& p``表示取其地址的右值表达式；

- 如果``p``是一个指针类型的右值表达式，或者当``p``是一个Coq中``addr``类型的值，那么``p # Int |-> v``表示在地址``p``上存储了一个32位整数``v``；

- 如果``p``是一个指针类型的右值表达式，或者当``p``是一个Coq中``addr``类型的值，那么``p # Ptr |-> v``表示在地址``p``上存储了一个指针``v``。

除此之外，上面定义中还用到了下面这些逻辑连接词或逻辑符号：

- ``emp``是分离逻辑常量断言，表示不占据空间；

- ``EX``表示存在；

- ``&&``表示普通合取，即“并且”；

- ``**``表示分离合取；

- ``[| ... |]``表示将与程序状态无关的数学命题当作断言。

考虑如果内存中存储的信息如下：

```
[0x0040 |-> 0; 0x0044 |-> 0x0100;
 0x0100 |-> 1; 0x0104 |-> 0x0108;
 0x0108 |-> 2; 0x010c |-> 0x0000]
```
并且``x = 0x0040``, ``y = 0x0100``，那么

| Coq表达式                | Coq表达式类型 | 对应的C表达式 | 值     |
| :----------------------- | :------------ | :------------ | :----- |
| x                        | 普通Coq表达式 | x             | 0x0040 |
| x # "list"               | 右值表达式    | x             | 0x0040 |
| x # "list" ->ₛ "data"    | 左值表达式    | x -> data     | /      |
| x # "list" ->ₛ "next"    | 左值表达式    | x -> next     | /      |
| &(x # "list" ->ₛ "data") | 右值表达式    | &(x -> data)  | 0x0040 |
| &(x # "list" ->ₛ "next") | 右值表达式    | &(x -> next)  | 0x0044 |

| Coq表达式                                                    | Coq表达式类型 | 真/假            |
| :----------------------------------------------------------- | :------------ | :--------------- |
| &(x # "list" ->ₛ "data") # Int \|-> 0                        | Assertion     | 在某子内存上为真 |
| &(x # "list" ->ₛ "data") # Int \|-> 1                        | Assertion     | 假               |
| &(x # "list" ->ₛ "data") # Int \|-> 0 && <br> &(x # "list" ->ₛ "data") # Int \|-> 0  <br>（一般不这么写） | Assertion     | 在某子内存上为真 |
| &(x # "list" ->ₛ "data") # Int \|-> 0 ** <br> &(x # "list" ->ₛ "data") # Int \|-> 0 | Assertion     | 假               |
| &(x # "list" ->ₛ "data") # Int \|-> 0 ** <br> &(x # "list" ->ₛ "next") # Ptr \|-> y | Assertion     | 在某子内存上为真 |
| sll x [0; 1; 2]                                              | Assertion     | 真               |

## 基于已有谓词定义新的谓词

在定义表示谓词的过程中可以基于已有谓词再定义新的谓词。例如，C程序中可能会用一个二阶指针``x``存储了一个链表的头指针。下面谓词就涵盖了地址``x``与链表所涉及的所有内存权限。

```
Definition sllb (x: addr) (l: list Z): Assertion :=
  EX y: addr, x # Ptr |-> y ** sll y l.
```











