在验证一个C函数时，我们需要在C程序中以标注的形式说明该函数对应的规约。一个C函数的规约包括一个逻辑参数列表（`With`，可以不写，不写则代表逻辑参数列表为空）和该函数对应的分离逻辑的前后条件（`Require`、`Ensure`）。

## 以单链表取反为例

例如，以下C函数是基于T1中定义的list类型实现的单链表的取反操作。

```c
struct list *reverse(struct list *p) {
  struct list *w, *t, *v;
  w = (void *) 0;
  v = p;
  while (v) {
    t = v->next;
    v->next = w;
    w = v;
    v = t;
  }
  return w;
}
```

对于这个函数，我们可以写出如下程序规约：

```c
struct list *reverse(struct list *p);
  /*@ With (l: list Z)
      Require sll(p, l)
      Ensure sll(__return, rev(l))
  */
```

这一规约读作：对于任意整数序列``l``，如果``reverse(p)``函数执行前，程序状态满足``sll(p, l)``性质，那么函数执行后它的返回值满足``sll(__return, rev(l))``。这里的``sll``就是我们刚刚定义的分离逻辑谓词，``rev``是Coq标准库中的列表取反函数，`__return`表示函数的返回值。

在这样的C函数规约中，前条件是一个关于C程序内存与函数形参数值的断言，后条件是一个关于C程序内存、函数形参数值与函数返回值的断言，它们都不是上面在Coq中所写的``Assertion``。在程序验证中，验证工具会以正确的方式处理这些在C文件中写入的规约标注。

C程序标注语言与Coq语法有所不同，下面是主要符号间的对比。

| 含义               | Coq表达式      | C标注表达式                                         |
| :----------------- | :------------- | :-------------------------------------------------- |
| 分离合取           | P ** Q         | P * Q                                               |
| 存在               | EX             | exists                                              |
| 相等               | =              | ==                                                  |
| 不等               | <>             | !=                                                  |
| 函数与谓词         | f x y          | f(x, y)                                             |
| 程序状态无关的命题 | [\| P \|]      | P                                                   |
| 存储32位整数       | p # Int \|-> v | data_at(p, int, v)                                  |
| 存储指针           | p # Ptr \|-> v | data_at(p, int *, v) <br> data_at(p, int * *, v) 等 |